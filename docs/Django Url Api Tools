# scripts/test_urls.py
"""
Django URL test/verify script

Usage:
  DJANGO_SETTINGS_MODULE=your_project.settings python scripts/test_urls.py

What it does:
  - Loads Django settings and URLconf
  - Walks all urlpatterns
  - Tests reversing named URLs and namespace resolution
  - Detects duplicate patterns (by regex / pattern string)
  - Detects includes that point to missing modules
  - Produces a markdown URL map at ./url_map.md

Notes:
  - Works with Django 2.0+ path()/re_path()/include()
  - Best-effort: some dynamic URL patterns may not be reversible without args
"""

from __future__ import annotations
import os
import sys
import argparse
import importlib
import traceback
from collections import defaultdict
from typing import List, Tuple, Dict, Any

# Bring up Django
try:
    import django
    from django.urls import URLPattern, URLResolver, get_resolver, reverse, NoReverseMatch
    from django.conf import settings
except Exception:
    # We'll try to give a nicer error if Django isn't configured
    pass


def setup_django(settings_module: str | None):
    if settings_module:
        os.environ.setdefault("DJANGO_SETTINGS_MODULE", settings_module)
    try:
        import django
        django.setup()
    except Exception as e:
        print("Failed to setup Django. Make sure DJANGO_SETTINGS_MODULE is set and importable.")
        raise


def iter_patterns(urlpatterns, prefix=""):
    """Yield tuples: (full_pattern, pattern_obj, namespace_stack, name)
    full_pattern is a human-friendly joined string.
    """
    for entry in urlpatterns:
        if isinstance(entry, URLPattern):
            name = entry.name
            pattern = prefix + getattr(entry.pattern, "_route", None) or str(entry.pattern)
            yield pattern, entry, [], name
        elif isinstance(entry, URLResolver):
            ns = entry.namespace
            sub_prefix = prefix + (getattr(entry.pattern, "_route", None) or str(entry.pattern))
            try:
                sub_patterns = entry.url_patterns
            except Exception:
                # include() pointed to unresolved module or raised during import
                yield sub_prefix, entry, [ns], None
                continue
            for pat, obj, ns_stack, name in iter_patterns(sub_patterns, sub_prefix):
                yield pat, obj, ([ns] if ns else []) + ns_stack, name
        else:
            # Unknown entry
            yield prefix + str(entry), entry, [], None


def find_duplicates(patterns: List[Tuple[str, Any, List[str], str]]):
    by_pattern = defaultdict(list)
    for pat, obj, ns, name in patterns:
        key = pat
        by_pattern[key].append((pat, obj, ns, name))
    dupes = {k: v for k, v in by_pattern.items() if len(v) > 1}
    return dupes


def test_reverse(patterns: List[Tuple[str, Any, List[str], str]]):
    """Attempt to reverse each named URL and namespace combos. Returns successes and failures."""
    successes = []
    failures = []
    for pat, obj, ns_stack, name in patterns:
        if not name:
            continue
        # Build names to test: plain name and with namespaces
        candidates = []
        full_ns = ":".join([n for n in ns_stack if n])
        if full_ns:
            candidates.append(f"{full_ns}:{name}")
        candidates.append(name)
        tried = set()
        ok = False
        for cand in candidates:
            if cand in tried:
                continue
            tried.add(cand)
            try:
                url = reverse(cand)
                successes.append((cand, url))
                ok = True
                break
            except NoReverseMatch:
                # some urls require args; try with dummy args: inspect the pattern
                try:
                    # naive: try reversing with a single kwarg 'pk'='1' and 'id'='1'
                    url = reverse(cand, kwargs={"pk": 1})
                    successes.append((cand, url))
                    ok = True
                    break
                except Exception:
                    pass
        if not ok:
            failures.append((name, ns_stack, pat))
    return successes, failures


def check_includes(patterns: List[Tuple[str, Any, List[str], str]]):
    """Detect URLResolver entries whose included module failed to provide url_patterns."""
    missing = []
    for pat, obj, ns, name in patterns:
        # URLResolver that doesn't expose url_patterns gracefully often indicates missing include
        from django.urls.resolvers import URLResolver as UR
        if isinstance(obj, UR):
            try:
                _ = obj.url_patterns
            except Exception as e:
                missing.append((pat, str(e)))
    return missing


def generate_url_map(patterns: List[Tuple[str, Any, List[str], str]], out_path="url_map.md"):
    lines = ["# URL Map", "", "Generated by scripts/test_urls.py", "", "| Pattern | Name | Namespaces | View |",
             "|---|---|---|---|"]
    for pat, obj, ns, name in patterns:
        view_repr = getattr(obj.callback, "__name__", str(type(obj))) if hasattr(obj, "callback") else str(type(obj))
        ns_display = ":".join([n for n in ns if n]) if any(ns) else ""
        lines.append(f"| `{pat}` | `{name}` | `{ns_display}` | `{view_repr}` |")
    with open(out_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))
    return out_path


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--settings", help="Django settings module (DJANGO_SETTINGS_MODULE)")
    parser.add_argument("--urlconf", help="Django root urlconf module (defaults to settings.ROOT_URLCONF)")
    parser.add_argument("--output", help="Path for generated URL map markdown", default="url_map.md")
    args = parser.parse_args()

    if args.settings:
        os.environ.setdefault("DJANGO_SETTINGS_MODULE", args.settings)
    if "DJANGO_SETTINGS_MODULE" not in os.environ:
        print("ERROR: Set DJANGO_SETTINGS_MODULE environment variable or pass --settings")
        sys.exit(2)

    try:
        import django
        django.setup()
        from django.urls import get_resolver
    except Exception as e:
        print("Failed to initialize Django: ", e)
        traceback.print_exc()
        sys.exit(1)

    try:
        resolver = get_resolver(args.urlconf)
    except Exception as e:
        print("Failed to get resolver:", e)
        traceback.print_exc()
        sys.exit(1)

    raw_patterns = []
    try:
        raw_patterns = list(iter_patterns(resolver.url_patterns))
    except Exception as e:
        print("Error walking URL patterns:", e)
        traceback.print_exc()

    print(f"Discovered {len(raw_patterns)} pattern entries (including includes)")

    dupes = find_duplicates(raw_patterns)
    if dupes:
        print("\nDuplicate URL patterns detected:\n")
        for k, v in dupes.items():
            print(f"Pattern: {k}")
            for _pat, _obj, _ns, _name in v:
                print(f"  - name={_name}, namespaces={_ns}")
    else:
        print("No duplicate URL patterns detected.")

    successes, failures = test_reverse(raw_patterns)
    print(f"\nReverse test successes: {len(successes)}")
    if failures:
        print(f"Reverse test failures: {len(failures)} (these may require args)")
        for name, ns_stack, pat in failures:
            print(f"  - name={name}, namespaces={ns_stack}, pattern={pat}")
    else:
        print("All named URL reverse lookups succeeded (or accepted dummy args).")

    missing_includes = check_includes(raw_patterns)
    if missing_includes:
        print(f"\nMissing includes / import errors in url includes: {len(missing_includes)}")
        for pat, err in missing_includes:
            print(f"  - pattern {pat}: error: {err}")
    else:
        print("No missing includes detected.")

    out = generate_url_map(raw_patterns, args.output)
    print(f"\nURL map written to: {out}")


if __name__ == "__main__":
    main()


# -----------------------------------------------------------
# scripts/generate_api_map.py
"""
Generates an API endpoint map for a Django project (best-effort).

What it tries to detect:
  - DRF Routers and viewsets (inspect urlpatterns for routers)
  - Function/class-based views mapped under urlpatterns
  - For DRF viewsets: attempts to extract .action mapping, http methods, permission_classes, serializer_class

Outputs:
  - api_map.json with a list of endpoints and metadata
  - api_map.md (human-readable)

Usage:
  DJANGO_SETTINGS_MODULE=your_project.settings python scripts/generate_api_map.py

Limitations:
  - This is best-effort. Highly dynamic routing, custom router classes, or view factories may not be fully analyzable.
"""

import json
import os
import sys
import argparse
import inspect
import traceback
from collections import defaultdict


def setup():
    if "DJANGO_SETTINGS_MODULE" not in os.environ:
        print("ERROR: Set DJANGO_SETTINGS_MODULE environment variable before running.")
        sys.exit(2)
    try:
        import django
        django.setup()
    except Exception as e:
        print("Failed to setup Django:", e)
        traceback.print_exc()
        sys.exit(1)


def gather_urlpatterns():
    from django.urls import get_resolver, URLPattern, URLResolver
    resolver = get_resolver()
    patterns = []

    def _recurse(patterns_list, prefix=""):
        for entry in patterns_list:
            if isinstance(entry, URLPattern):
                route = prefix + (getattr(entry.pattern, "_route", None) or str(entry.pattern))
                patterns.append((route, entry.callback, entry))
            elif isinstance(entry, URLResolver):
                route = prefix + (getattr(entry.pattern, "_route", None) or str(entry.pattern))
                try:
                    _recurse(entry.url_patterns, route)
                except Exception:
                    patterns.append((route, entry, entry))
            else:
                patterns.append((prefix + str(entry), entry, entry))

    _recurse(resolver.url_patterns)
    return patterns


def extract_drf_info(callback):
    """Try to extract DRF-like metadata from a view or viewset callable."""
    info = {}
    try:
        # If it's a viewset class, callback may be 'SomeViewSet.as_view({...})' -> function with cls attrs
        view_cls = getattr(callback, "cls", None) or getattr(callback, "view_class", None)
        if view_cls is None and inspect.isfunction(callback):
            # For function-based DRF views decorated by api_view, there's an attribute 'cls'? not necessarily.
            view_cls = getattr(callback, "view_class", None)
        if view_cls is not None:
            # permission_classes
            perms = getattr(view_cls, "permission_classes", None)
            info["permission_classes"] = [getattr(p, "__name__", str(p)) for p in (perms or [])]
            info["serializer_class"] = getattr(view_cls, "serializer_class", None) and getattr(view_cls, "serializer_class").__name__ or None
            # try to detect actions
            if hasattr(view_cls, "actions"):
                info["actions"] = dict(view_cls.actions)
    except Exception:
        pass
    return info


def determine_methods(callback):
    """Return allowed HTTP methods for the callback (best effort)."""
    methods = []
    try:
        if hasattr(callback, "actions"):
            # DRF viewset .actions maps http method name to action name
            for m in callback.actions.keys():
                methods.append(m.upper())
        elif hasattr(callback, "cls"):
            # DRF as_view wrapper
            cls = callback.cls
            for m in ("get", "post", "put", "patch", "delete", "head", "options"):
                if hasattr(cls, m):
                    methods.append(m.upper())
        else:
            # naive: inspect function name or attributes
            if hasattr(callback, "allowed_methods"):
                methods = list(getattr(callback, "allowed_methods") or [])
            else:
                # fallback: common methods
                methods = ["GET"]
    except Exception:
        methods = ["GET"]
    return sorted(set(m.upper() for m in methods))


def build_api_map(out_json="api_map.json", out_md="api_map.md"):
    patterns = gather_urlpatterns()
    api_entries = []
    for route, callback, entry in patterns:
        try:
            view_name = None
            if hasattr(callback, "__name__"):
                view_name = callback.__name__
            elif hasattr(callback, "__class__"):
                view_name = callback.__class__.__name__
            else:
                view_name = str(callback)

            methods = determine_methods(callback)
            drf_info = extract_drf_info(callback)

            entry_data = {
                "route": route,
                "view": view_name,
                "methods": methods,
                "permissions": drf_info.get("permission_classes", []),
                "serializer": drf_info.get("serializer_class"),
                "notes": "",
            }

            # Try to read docstring for request/response format hints
            doc = inspect.getdoc(callback)
            if doc:
                entry_data["notes"] = doc.split("\n")[0]

            api_entries.append(entry_data)
        except Exception as e:
            api_entries.append({"route": route, "view": str(callback), "error": str(e)})

    # write json
    with open(out_json, "w", encoding="utf-8") as f:
        json.dump(api_entries, f, indent=2, ensure_ascii=False)

    # write markdown
    lines = ["# API Map", "", "Generated by scripts/generate_api_map.py", "", "| Route | Methods | View | Permissions | Serializer | Notes |",
             "|---|---|---|---|---|---|"]
    for e in api_entries:
        route = e.get("route")
        methods = ",".join(e.get("methods") or [])
        view = e.get("view")
        perms = ",".join(e.get("permissions") or [])
        ser = e.get("serializer") or ""
        notes = e.get("notes") or e.get("error", "")
        lines.append(f"| `{route}` | `{methods}` | `{view}` | `{perms}` | `{ser}` | {notes} |")
    with open(out_md, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))

    return out_json, out_md


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--settings", help="Django settings module (DJANGO_SETTINGS_MODULE)")
    parser.add_argument("--out_json", default="api_map.json")
    parser.add_argument("--out_md", default="api_map.md")
    args = parser.parse_args()

    if args.settings:
        os.environ.setdefault("DJANGO_SETTINGS_MODULE", args.settings)

    setup()
    a, b = build_api_map(args.out_json, args.out_md)
    print(f"Wrote API map to: {a} and {b}")
