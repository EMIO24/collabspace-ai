"""
Django URL test/verify script

Usage:
  DJANGO_SETTINGS_MODULE=your_project.settings python scripts/test_urls.py

What it does:
  - Loads Django settings and URLconf
  - Walks all urlpatterns
  - Tests reversing named URLs and namespace resolution
  - Detects duplicate patterns (by regex / pattern string)
  - Detects includes that point to missing modules
  - Produces a markdown URL map at ./url_map.md

Notes:
  - Works with Django 2.0+ path()/re_path()/include()
  - Best-effort: some dynamic URL patterns may not be reversible without args
"""

from __future__ import annotations
import os
import sys
import argparse
import importlib
import traceback
from collections import defaultdict
from typing import List, Tuple, Dict, Any

# Bring up Django
try:
    import django
    from django.urls import URLPattern, URLResolver, get_resolver, reverse, NoReverseMatch
    from django.conf import settings
except Exception:
    # We'll try to give a nicer error if Django isn't configured
    pass


def setup_django(settings_module: str | None):
    if settings_module:
        os.environ.setdefault("DJANGO_SETTINGS_MODULE", settings_module)
    try:
        import django
        django.setup()
    except Exception as e:
        print("Failed to setup Django. Make sure DJANGO_SETTINGS_MODULE is set and importable.")
        raise


def iter_patterns(urlpatterns, prefix=""):
    """Yield tuples: (full_pattern, pattern_obj, namespace_stack, name)
    full_pattern is a human-friendly joined string.
    """
    for entry in urlpatterns:
        if isinstance(entry, URLPattern):
            name = entry.name
            pattern = prefix + getattr(entry.pattern, "_route", None) or str(entry.pattern)
            yield pattern, entry, [], name
        elif isinstance(entry, URLResolver):
            ns = entry.namespace
            sub_prefix = prefix + (getattr(entry.pattern, "_route", None) or str(entry.pattern))
            try:
                sub_patterns = entry.url_patterns
            except Exception:
                # include() pointed to unresolved module or raised during import
                yield sub_prefix, entry, [ns], None
                continue
            for pat, obj, ns_stack, name in iter_patterns(sub_patterns, sub_prefix):
                yield pat, obj, ([ns] if ns else []) + ns_stack, name
        else:
            # Unknown entry
            yield prefix + str(entry), entry, [], None


def find_duplicates(patterns: List[Tuple[str, Any, List[str], str]]):
    by_pattern = defaultdict(list)
    for pat, obj, ns, name in patterns:
        key = pat
        by_pattern[key].append((pat, obj, ns, name))
    dupes = {k: v for k, v in by_pattern.items() if len(v) > 1}
    return dupes


def test_reverse(patterns: List[Tuple[str, Any, List[str], str]]):
    """Attempt to reverse each named URL and namespace combos. Returns successes and failures."""
    successes = []
    failures = []
    for pat, obj, ns_stack, name in patterns:
        if not name:
            continue
        # Build names to test: plain name and with namespaces
        candidates = []
        full_ns = ":".join([n for n in ns_stack if n])
        if full_ns:
            candidates.append(f"{full_ns}:{name}")
        candidates.append(name)
        tried = set()
        ok = False
        for cand in candidates:
            if cand in tried:
                continue
            tried.add(cand)
            try:
                url = reverse(cand)
                successes.append((cand, url))
                ok = True
                break
            except NoReverseMatch:
                # some urls require args; try with dummy args: inspect the pattern
                try:
                    # naive: try reversing with a single kwarg 'pk'='1' and 'id'='1'
                    url = reverse(cand, kwargs={"pk": 1})
                    successes.append((cand, url))
                    ok = True
                    break
                except Exception:
                    pass
        if not ok:
            failures.append((name, ns_stack, pat))
    return successes, failures


def check_includes(patterns: List[Tuple[str, Any, List[str], str]]):
    """Detect URLResolver entries whose included module failed to provide url_patterns."""
    missing = []
    for pat, obj, ns, name in patterns:
        # URLResolver that doesn't expose url_patterns gracefully often indicates missing include
        from django.urls.resolvers import URLResolver as UR
        if isinstance(obj, UR):
            try:
                _ = obj.url_patterns
            except Exception as e:
                missing.append((pat, str(e)))
    return missing


def generate_url_map(patterns: List[Tuple[str, Any, List[str], str]], out_path="url_map.md"):
    lines = ["# URL Map", "", "Generated by scripts/test_urls.py", "", "| Pattern | Name | Namespaces | View |",
             "|---|---|---|---|"]
    for pat, obj, ns, name in patterns:
        view_repr = getattr(obj.callback, "__name__", str(type(obj))) if hasattr(obj, "callback") else str(type(obj))
        ns_display = ":".join([n for n in ns if n]) if any(ns) else ""
        lines.append(f"| `{pat}` | `{name}` | `{ns_display}` | `{view_repr}` |")
    with open(out_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))
    return out_path


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--settings", help="Django settings module (DJANGO_SETTINGS_MODULE)")
    parser.add_argument("--urlconf", help="Django root urlconf module (defaults to settings.ROOT_URLCONF)")
    parser.add_argument("--output", help="Path for generated URL map markdown", default="url_map.md")
    args = parser.parse_args()

    if args.settings:
        os.environ.setdefault("DJANGO_SETTINGS_MODULE", args.settings)
    if "DJANGO_SETTINGS_MODULE" not in os.environ:
        print("ERROR: Set DJANGO_SETTINGS_MODULE environment variable or pass --settings")
        sys.exit(2)

    try:
        import django
        django.setup()
        from django.urls import get_resolver
    except Exception as e:
        print("Failed to initialize Django: ", e)
        traceback.print_exc()
        sys.exit(1)

    try:
        resolver = get_resolver(args.urlconf)
    except Exception as e:
        print("Failed to get resolver:", e)
        traceback.print_exc()
        sys.exit(1)

    raw_patterns = []
    try:
        raw_patterns = list(iter_patterns(resolver.url_patterns))
    except Exception as e:
        print("Error walking URL patterns:", e)
        traceback.print_exc()

    print(f"Discovered {len(raw_patterns)} pattern entries (including includes)")

    dupes = find_duplicates(raw_patterns)
    if dupes:
        print("\nDuplicate URL patterns detected:\n")
        for k, v in dupes.items():
            print(f"Pattern: {k}")
            for _pat, _obj, _ns, _name in v:
                print(f"  - name={_name}, namespaces={_ns}")
    else:
        print("No duplicate URL patterns detected.")

    successes, failures = test_reverse(raw_patterns)
    print(f"\nReverse test successes: {len(successes)}")
    if failures:
        print(f"Reverse test failures: {len(failures)} (these may require args)")
        for name, ns_stack, pat in failures:
            print(f"  - name={name}, namespaces={ns_stack}, pattern={pat}")
    else:
        print("All named URL reverse lookups succeeded (or accepted dummy args).")

    missing_includes = check_includes(raw_patterns)
    if missing_includes:
        print(f"\nMissing includes / import errors in url includes: {len(missing_includes)}")
        for pat, err in missing_includes:
            print(f"  - pattern {pat}: error: {err}")
    else:
        print("No missing includes detected.")

    out = generate_url_map(raw_patterns, args.output)
    print(f"\nURL map written to: {out}")


if __name__ == "__main__":
    main()
